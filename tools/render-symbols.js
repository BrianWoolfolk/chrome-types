#!/usr/bin/env node
/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @fileoverview Renders symbol data for a specific Chrome APIs bundle. This is part of the process
 * to generate version data over time.
 */


import getStdin from 'get-stdin';
import * as chromeTypes from '../types/chrome.js';
import mri from 'mri';
import { RenderContext } from './lib/render-context.js';
import { FeatureQueryAll, RenderOverride } from './override.js';
import log from 'fancy-log';


async function run() {
  const argv = mri(process.argv.slice(2), {
    boolean: ['help', 'all'],
    alias: {
      'help': ['h'],
      'all': ['a'],
    },
    unknown: (v) => {
      throw new Error(`unexpected flag: ${v}`);
    },
  });

  if (argv.help || argv._.length !== 0) {
    console.warn(`Usage: cat apis.json | render-symbols.js > out.json

Prepares a JSON payload containing all symbols and their channel, based on the
JSON payload generated by "prepare.js". Renders the generated file to stdout.
This is used internally to generate historic version data for Chrome's APIs.
`);
    process.exit(0);
  }

  /** @type {chromeTypes.ProcessedAPIData} */
  const o = JSON.parse(await getStdin());

  const fq = new FeatureQueryAll(o.feature);
  const renderOverride = new RenderOverride(o.api, fq);
  const renderContext = new RenderContext(renderOverride);

  /** @type {Map<string, chromeTypes.TypeSpec>} */
  const symbols = new Map();

  renderContext.addCallback((spec, id) => {
    if (symbols.has(id)) {
      throw new Error(`got dup symbol: ${id}`);
    }

    // This should never happen: void symbols shouldn't be passed here (and only exist as return
    // values anyway).
    if (spec.type === 'void') {
      throw new Error(`got void`);
    }

    symbols.set(id, spec);
  });

  renderContext.renderAll(Object.values(o.api));

  const keys = [...symbols.keys()];
  keys.sort((a, b) => {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return +1;
    }
    return 0;
  });

  let deprecatedCount = 0;
  let nonStableCount = 0;

  const out = Object.fromEntries(keys.map((id) => {
    const spec = /** @type {chromeTypes.TypeSpec} */ (symbols.get(id));

    // This generates override tags, but doesn't include e.g., deprecated which comes from the spec.
    const tags = renderOverride.completeTagsFor(id);
    const channel = /** @type {chromeTypes.Channel|undefined} */ (tags.find(({ name }) => name === 'chrome-channel')?.value);

    /** @type {{channel?: chromeTypes.Channel, deprecated?: true}} */
    const o = {};
    if (channel && channel !== 'stable') {
      o.channel = channel;
      ++nonStableCount;
    }
    if (spec.deprecated) {
      o.deprecated = true;
      ++deprecatedCount;
    }

    return [id, o];
  }));

  log.warn(`Found ${Object.keys(out).length} symbols, ${deprecatedCount} deprecated, ${nonStableCount} not stable`);

  process.stdout.write(JSON.stringify(out, undefined, 2));
}


run();