#!/usr/bin/env node
/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import getStdin from 'get-stdin';
import * as chromeTypes from '../types/chrome.js';
import * as overrideTypes from '../types/override.js';
import * as fs from 'fs';
import mri from 'mri';
import { buildNamespaceAwareMarkdownRewrite } from './lib/comment.js';
import { namespaceNameFromId, parentId } from './lib/traverse.js';
import { RenderContext } from './lib/render-context.js';
import { FeatureQuery } from './lib/feature-query.js';
import { mostReleasedChannel } from './lib/channel.js';
import log from 'fancy-log';


async function run() {
  const argv = mri(process.argv.slice(2), {
    boolean: ['help', 'all'],
    alias: {
      'help': ['h'],
      'all': ['a'],
    },
    unknown: (v) => {
      throw new Error(`unexpected flag: ${v}`);
    },
  });

  if (argv.help || argv._.length !== 0) {
    console.warn(`Usage: cat apis.json | tsd.js > out.d.ts

Prepares the TypeScript Definitions file containing Chrome APIs based on the
JSON payload generated by "prepare.js". Renders the generated file to stdout.

Options:
  -a, --all            generate all (including Platform Apps), not just MV3+
`);
    process.exit(0);
  }

  const renderAt = new Date();

  /** @type {chromeTypes.ProcessedAPIData} */
  const o = JSON.parse(await getStdin());

  const allNamespaceNames = Object.keys(o.api);

  /** @type {string[]} */
  const renderParts = [];

  const versionSuffix = o.version ? ` (${o.version.version})` : '';
  renderParts.push(`/**
 * Copyright ${renderAt.getFullYear()} Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated on ${renderAt}
// Built at ${o.definitionsRevision}${versionSuffix}`);

  /** @type {FeatureQuery} */
  let fq;

  if (argv.all) {
    // We include all APIs, MV2 and MV3 etc, to render on the site.
    fq = new FeatureQueryAll(o.feature);

    renderParts.push(`// Includes all types, including MV2 + Platform Apps APIs.`);

  } else {
    fq = new FeatureQueryModern(o.feature);

    renderParts.push(`// Includes MV3+ APIs only.`);

    const extraMV3File = new URL('../content/extra-mv3.d.ts', import.meta.url);
    renderParts.push(fs.readFileSync(extraMV3File, 'utf-8'));
  }

  const preambleFile = new URL('../content/preamble.d.ts', import.meta.url);
  renderParts.push(fs.readFileSync(preambleFile, 'utf-8'));

  const renderOverride = new RenderOverride(allNamespaceNames, fq);

  earlyOverride(o.api);
  const renderContext = new RenderContext(renderOverride);

  /** @type {Map<string, any>} */
  const keys = new Map();

  renderContext.addCallback((spec, id, tags) => {0
    if (keys.has(id)) {
      throw new Error(`got dup id: ${id}`);
    }

    // should never happen
    if (spec.type === 'void') {
      throw new Error(`got void`);
    }

    // TODO: do something with this
    keys.set(id, spec);
    console.warn('symbol', id);
  });

  const buf = renderContext.renderAll(Object.values(o.api));
  renderParts.push(buf.render(true));

  const out = Buffer.from(renderParts.join('\n\n'));
  log.warn(`Built ${argv.all ? 'all' : 'MV3+'} types, generated ${out.length} bytes of .d.ts`);

  process.stdout.write(out);
}


/**
 * @param {{[api: string]: chromeTypes.NamespaceSpec}} api
 */
function earlyOverride(api) {
  // Fix contextMenus not having the right OnClickData type.
  const existing = api['contextMenus'].types?.find(({ id }) => id === 'OnClickData');
  if (!existing) {
    const clone = [
      ...api['contextMenusInternal'].types ?? [],
    ].map((x) => {
      return { ...x, nodoc: false };
    });
    api['contextMenus'].types?.push(...clone);
  }

  // Fix contextMenus.onClicked incorrectly $ref-ing another function.
  const onClickedEvent = api['contextMenus'].events?.find(({ name }) => name === 'onClicked');
  if (onClickedEvent && onClickedEvent.$ref) {
    delete onClickedEvent.$ref;
    onClickedEvent.parameters = [
      { $ref: 'OnClickData', name: 'info' },
      { $ref: 'tabs.Tab', name: 'tab' },
    ];
  }
}


class FeatureQueryModern extends FeatureQuery {

  /**
   * @param {chromeTypes.FeatureSpec} f
   * @return {boolean}
   */
  filter(f) {
    // Don't show anything that maxes out before MV3.
    if (f.max_manifest_version && f.max_manifest_version < 3) {
      return false;
    }

    // Remove non-extension APIs.
    if (f.extension_types && !f.extension_types.includes('extension')) {
      return false;
    }

    return super.filter(f);
  }

}


class FeatureQueryAll extends FeatureQuery {

  /**
   * @param {chromeTypes.FeatureSpec[]} q
   * @return {chromeTypes.FeatureSpec | null | void}
   */
  mergeComplexFeature(q) {
    const s = super.mergeComplexFeature(q);
    if (s !== undefined) {
      return s;
    }

    // Filter (potentially) by channel. Choose the most released channel (e.g., 'stable' over 'beta').
    const bestChannel = q.reduce((channel, spec) => mostReleasedChannel(channel, spec.channel), /** @type {chromeTypes.Channel | undefined} */(undefined));
    const bestChannelFilter = q.filter(({ channel }) => channel === bestChannel);
    if (bestChannelFilter.length === 1) {
      return bestChannelFilter[0];
    }

    // Filter by extension (prefer).
    const extensionFilter = q.filter(({ extension_types }) => extension_types?.includes('extension'));
    if (extensionFilter.length === 1) {
      return extensionFilter[0];
    }
  }
}


/**
 * @implements {overrideTypes.RenderOverride}
 */
class RenderOverride {
  #commentRewriter;
  #fq;

  /**
   * @param {Iterable<string>} allNamespaceNames
   * @param {FeatureQuery} fq
   */
  constructor(allNamespaceNames, fq) {
    this.#commentRewriter = buildNamespaceAwareMarkdownRewrite(allNamespaceNames);
    this.#fq = fq;
  }

  /**
   * @param {chromeTypes.TypeSpec} spec
   * @param {string} id
   */
  isVisible(spec, id) {
    // Hide a number of internal APIs that aren't specifically disallowed in the feature files.
    const parts = id.split('.');
    if (['api:test', 'api:idltest'].includes(parts[0])) {
      return false;
    }
    const invalid = parts.some((part) => {
      return part.endsWith('Private') || part.endsWith('Internal');
    })
    if (invalid) {
      return false;
    }

    // If this is just a disallowed feature (e.g., it has a specific allowlist) then skip it.
    if (!this.#fq.isAvailable(id)) {
      return false;
    }

    switch (id) {
      case 'api:notifications.NotificationBitmap':
        // In old versions of Chrome, this is incorrectly marked nodoc.
        return true;

      case 'api:declarativeContent.ShowAction':
        // This is incorrectly referenced even though it's marked nodoc.
        return true;
    }
    return !spec.nodoc;
  }

  /**
   * @param {string} id
   */
  objectTemplatesFor(id) {
    switch (id) {
      case 'api:events.Event':
        return 'H, C = void, A = void';

      case 'api:events.Rule':
        return 'C = any, A = any';

      case 'api:contentSettings.ContentSetting':
        return 'T';

      case 'api:types.ChromeSetting':
        return 'T';
    }
  }

  /**
   * @param {chromeTypes.TypeSpec} spec
   * @param {string} id
   */
  typeOverride(spec, id) {
    // Replace callback types to do with Event.
    switch (id) {
      case 'api:events.Event.addListener.callback':
      case 'api:events.Event.removeListener.callback':
      case 'api:events.Event.hasListener.callback':
        return { $ref: 'H' };

      case 'api:events.Event.addRules.rules._':
      case 'api:events.Event.addRules.callback.rules._':
      case 'api:events.Event.getRules.callback.rules._':
        return { $ref: 'Rule', value: ['', { $ref: 'C' }, { $ref: 'A' }] };
    }

    // Fix bad runtime.Port APIs in older Chrome versions.
    if (spec.$ref === 'events.Event' && !spec.value) {
      /** @type {chromeTypes.TypeSpec[]} */
      const parameters = [];

      /** @type {chromeTypes.TypeSpec} */
      const functionType = { type: 'function', parameters };

      /** @type {chromeTypes.TypeSpec} */
      const update = { ...spec, value: ['', functionType] };

      switch (id) {
        case 'api:runtime.Port.onMessage':
          parameters.push({ type: 'any', name: 'message' });
        // fall-through

        case 'api:runtime.Port.onDisconnect':
          parameters.push({ $ref: 'Port', name: 'port' });
          break;
      }

      return update;
    }

    // Fix bad contextMenusInternal references in older Chrome versions.
    if (spec.$ref && spec.$ref.startsWith('contextMenusInternal.') && !id.startsWith('api:contextMenusInternal.')) {
      spec.$ref = spec.$ref.replace(/^contextMenusInternal\./, 'contextMenus.');
    }

    // Fix isInstanceOf usages.
    switch (spec.isInstanceOf) {
      case 'Promise':
        return { $ref: 'Promise', value: ['', { type: 'any' }] };

      case 'global':
        return { $ref: 'Window' };
    }

    // Upgrade ambiguous "any" to better template types as needed.
    if (spec.type === 'any') {
      switch (id) {
        case 'api:events.Rule.conditions._':
          return { $ref: 'C' };

        case 'api:events.Rule.actions._':
          return { $ref: 'A' };

        case 'api:contentSettings.ContentSetting.get.return.setting':
        case 'api:contentSettings.ContentSetting.get.callback.details.setting':
        case 'api:types.ChromeSetting.set.details.setting':
          return { $ref: 'T' };

        case 'api:types.ChromeSetting.onChange.details.value':
        case 'api:types.ChromeSetting.get.return.value':
        case 'api:types.ChromeSetting.get.callback.details.value':
        case 'api:types.ChromeSetting.set.details.value':
          return { $ref: 'T' };
      }
    }
  }

  /**
   * Generates all extra tags for this node, which may be filtered if they match the tags of our
   * parent. These may include duplicate tags.
   *
   * @param {string} id
   */
  completeTagsFor(id) {
    /** @type {{name: string, value?: string, keep?: true}[]} */
    const tags = [];

    /** @type {chromeTypes.Channel | undefined} */
    let bestChannel = undefined;

    /** @type {boolean} */
    let disallowForServiceWorkers = false;

    /** @type {number} */
    let maxManifestVersion = Infinity;

    /** @type {number} */
    let minManifestVersion = 0;

    /** @type {Set<chromeTypes.Platform>} */
    const platforms = new Set();

    /** @type {boolean} */
    let isOnlyPlatformApps = false;

    // Actually loop over all features.
    // Note that this generates an OR: e.g., accessibilityFeatures requires _either_
    // "permission:accessibilityFeatures.read" OR "permission:accessibilityFeatures.write", and we
    // just include both semi-ambiguously (the site never says OR or AND).
    this.#fq.checkFeature(id, (f, otherId) => {
      if (otherId.startsWith('permission:')) {
        const value = otherId.substr('permission:'.length);
        tags.push({ name: 'chrome-permission', value });
      }

      if (otherId.startsWith('manifest:')) {
        const value = otherId.substr('manifest:'.length);
        tags.push({ name: 'chrome-manifest', value });
      }

      bestChannel = mostReleasedChannel(bestChannel, f.channel);
      disallowForServiceWorkers = disallowForServiceWorkers || (f.disallow_for_service_workers ?? false);

      // nb. In practice we see only min or max. (min for MV3+, max for MV2)
      // TODO: If there is later a MV4, this will need to be updated.
      maxManifestVersion = Math.min(f.max_manifest_version ?? Infinity, maxManifestVersion);
      minManifestVersion = Math.max(f.min_manifest_version ?? 0, minManifestVersion);

      (f.platforms ?? []).forEach((platform) => platforms.add(platform));

      if (f.extension_types && !f.extension_types.includes('extension') && f.extension_types.includes('platform_app')) {
        isOnlyPlatformApps = true;
      }
    });

    bestChannel = bestChannel ?? 'stable';
    if (bestChannel === 'stable') {
      // Ignore, implied
    } else if (bestChannel === 'beta') {
      tags.push({ name: 'chrome-channel', value: 'beta' });
      tags.unshift({ name: 'beta' });
    } else {
      tags.push({ name: 'chrome-channel', value: bestChannel });
      tags.unshift({ name: 'alpha' });
    }

    if (isOnlyPlatformApps) {
      tags.push({ name: 'chrome-platform-apps' });
    }

    if (disallowForServiceWorkers) {
      tags.push({ name: 'chrome-disallow-service-workers' });
    }

    if (maxManifestVersion !== Infinity) {
      const value = `MV${maxManifestVersion}`;
      tags.push({ name: 'chrome-max-manifest', value });
    }
    if (minManifestVersion !== 0) {
      const value = `MV${minManifestVersion}`;
      tags.push({ name: 'chrome-min-manifest', value });
    }

    // This can surface a few values but we generally only end up showing "chromeos".
    platforms.forEach((value) => {
      tags.push({ name: 'chrome-platform', value });
    });

    // Ensure we only return unique tags.
    /** @type {Set<string>} */
    const uniqueSet = new Set();
    return tags.filter((tag) => {
      const key = `${tag.name}/${tag.value ?? ''}/${tag.keep ?? 'false'}`;
      if (uniqueSet.has(key)) {
        return false;
      }
      uniqueSet.add(key);
      return true;
    });
  }

  /**
   * @param {chromeTypes.TypeSpec} spec
   * @param {string} id
   */
  tagsFor(spec, id) {
    let tags = this.completeTagsFor(id);

    const parent = parentId(id);
    if (parent) {
      const parentTags = this.completeTagsFor(parent);
      tags = tags.filter((tag) => {
        if (tag.keep) {
          return true;  // don't filter this one
        }
        // Look for an exact matching parent tag. If we find one, don't include this here.
        return !parentTags.find((parentTag) => {
          return tag.name === parentTag.name && tag.value === parentTag.value;
        });
      });
    }

    return tags;
  }

  /**
   * @param {string} s
   * @param {string} id
   */
  rewriteComment(s, id) {
    const namespace = namespaceNameFromId(id);
    const update = this.#commentRewriter(namespace, s);
    if (update !== s) {
      return update;
    }
  }
}


run();
