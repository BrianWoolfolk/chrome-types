#!/usr/bin/env node
/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import getStdin from 'get-stdin';
import * as chromeTypes from '../types/chrome.js';
import * as overrideTypes from '../types/override.js';
import * as fs from 'fs';
import mri from 'mri';
import { buildNamespaceAwareMarkdownRewrite } from './lib/comment.js';
import { namespaceNameFromId } from './lib/traverse.js';
import { RenderContext } from './lib/render-context.js';


async function run() {
  const argv = mri(process.argv.slice(2), {
    boolean: ['help', 'all'],
    alias: {
      'help': ['h'],
      'all': ['a'],
    },
    unknown: (v) => {
      throw new Error(`unexpected flag: ${v}`);
    },
  });

  if (argv.help || argv._.length !== 0) {
    console.warn(`Usage: cat apis.json | tsd.js > out.d.ts

Prepares the TypeScript Definitions file containing Chrome APIs based on the
JSON payload generated by "prepare.js". Renders the generated file to stdout.

Options:
  -a, --all            generate all types (for site), not just MV3+
`);
    process.exit(0);
  }

  /** @type {chromeTypes.ProcessedAPIData} */
  const o = JSON.parse(await getStdin());

  const allNamespaceNames = Object.keys(o.api);
  const renderOverride = buildRenderOverride(allNamespaceNames);

  if (!argv.all) {
    // TODO: filter stuff
  }

  const renderContext = new RenderContext(renderOverride);
  const buf = renderContext.renderAll(Object.values(o.api));
  const out = buf.render(true);

  const preambleFile = new URL('../content/preamble.d.ts', import.meta.url);
  const preambleContent = fs.readFileSync(preambleFile);

  process.stdout.write(preambleContent + `\n\n// Generated on ${new Date}\n\n\n` + out);
}


/**
 * @param {Iterable<string>} allNamespaceNames
 * @return {overrideTypes.RenderOverride}
 */
function buildRenderOverride(allNamespaceNames) {
  const commentRewriter = buildNamespaceAwareMarkdownRewrite(allNamespaceNames);

  return {
    isVisible(spec, id) {
      switch (id) {
        case 'api:declarativeContent.ShowAction':
          // This is incorrectly referenced even though it's marked nodoc.
          return true;
      }
      return !spec.nodoc;
    },

    objectTemplatesFor(id) {
      switch (id) {
        case 'api:events.Event':
          return 'H, C = void, A = void';

        case 'api:events.Rule':
          return 'C = any, A = any';

        case 'api:contentSettings.ContentSetting':
          return 'T';

        case 'api:types.ChromeSetting':
          return 'T';
      }
    },

    typeOverride(spec, id) {
      // Replace callback types to do with Event.
      switch (id) {
        case 'api:events.Event.addListener.callback':
        case 'api:events.Event.removeListener.callback':
        case 'api:events.Event.hasListener.callback':
          return { $ref: 'H' };

        case 'api:events.Event.addRules.rules._':
        case 'api:events.Event.addRules.callback.rules._':
        case 'api:events.Event.getRules.callback.rules._':
          return { $ref: 'Rule', value: ['', { $ref: 'C' }, { $ref: 'A' }] };
      }

      // Fix isInstanceOf usages.
      switch (spec.isInstanceOf) {
        case 'Promise':
          return { $ref: 'Promise', value: ['', { type: 'any' }] };

        case 'global':
          return { $ref: 'Window' };
      }

      // Upgrade ambiguous "any" to better template types as needed.
      if (spec.type === 'any') {
        switch (id) {
          case 'api:events.Rule.conditions._':
            return { $ref: 'C' };

          case 'api:events.Rule.actions._':
            return { $ref: 'A' };

          case 'api:contentSettings.ContentSetting.get.return.setting':
          case 'api:contentSettings.ContentSetting.get.callback.details.setting':
          case 'api:types.ChromeSetting.set.details.setting':
            return { $ref: 'T' };

          case 'api:types.ChromeSetting.onChange.details.value':
          case 'api:types.ChromeSetting.get.return.value':
          case 'api:types.ChromeSetting.get.callback.details.value':
          case 'api:types.ChromeSetting.set.details.value':
            return { $ref: 'T' };
        }
      }
    },

    tagsFor(spec, id) {
      // TODO: missing for now
      if (1) {
        return [];
      }
    },

    rewriteComment(s, id) {
      const namespace = namespaceNameFromId(id);
      return commentRewriter(namespace, s);
    },
  };
}


run();
