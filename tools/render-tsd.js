#!/usr/bin/env node
/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import getStdin from 'get-stdin';
import * as chromeTypes from '../types/chrome.js';
import * as overrideTypes from '../types/override.js';
import * as fs from 'fs';
import mri from 'mri';
import { buildNamespaceAwareMarkdownRewrite } from './lib/comment.js';
import { namespaceNameFromId } from './lib/traverse.js';
import { RenderContext } from './lib/render-context.js';
import { FeatureQuery } from './lib/feature-query.js';


async function run() {
  const argv = mri(process.argv.slice(2), {
    boolean: ['help', 'all'],
    alias: {
      'help': ['h'],
      'all': ['a'],
    },
    unknown: (v) => {
      throw new Error(`unexpected flag: ${v}`);
    },
  });

  if (argv.help || argv._.length !== 0) {
    console.warn(`Usage: cat apis.json | tsd.js > out.d.ts

Prepares the TypeScript Definitions file containing Chrome APIs based on the
JSON payload generated by "prepare.js". Renders the generated file to stdout.

Options:
  -a, --all            generate all (including Platform Apps), not just MV3+
`);
    process.exit(0);
  }

  const renderAt = new Date();

  /** @type {chromeTypes.ProcessedAPIData} */
  const o = JSON.parse(await getStdin());

  const allNamespaceNames = Object.keys(o.api);

  /** @type {string[]} */
  const renderParts = [];

  const versionSuffix = o.version ? ` (${o.version.version})` : '';
  renderParts.push(`/**
 * Copyright ${renderAt.getFullYear()} Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated on ${renderAt}
// Built at ${o.definitionsRevision}${versionSuffix}
`);

  const preambleFile = new URL('../content/preamble.d.ts', import.meta.url);
  renderParts.push(fs.readFileSync(preambleFile, 'utf-8'));

  /** @type {FeatureQuery} */
  let fq;

  if (argv.all) {
    // We include all APIs, MV2 and MV3 etc, to render on the site.
    fq = new FeatureQuery(o.feature);

  } else {
    // Filter to only extension APIs.
    /** @type {(f: chromeTypes.FeatureSpec) => boolean} */
    const extraFilter = (f) => {
      return !f.extension_types || f.extension_types.includes('extension');
    };
    fq = new FeatureQuery(o.feature, extraFilter);

    const extraMV3File = new URL('../content/extra-mv3.d.ts', import.meta.url);
    renderParts.push(fs.readFileSync(extraMV3File, 'utf-8'));
  }

  const renderOverride = new RenderOverride(allNamespaceNames, fq);

  earlyOverride(o.api);
  const renderContext = new RenderContext(renderOverride);
  const buf = renderContext.renderAll(Object.values(o.api));
  renderParts.push(buf.render(true));

  process.stdout.write(renderParts.join('\n'));
}


/**
 * @param {{[api: string]: chromeTypes.NamespaceSpec}} api
 */
function earlyOverride(api) {
  // Fix contextMenus not having the right OnClickData type.
  const existing = api['contextMenus'].types?.find(({id}) => id === 'OnClickData');
  if (!existing) {
    const clone = [
      ...api['contextMenusInternal'].types ?? [],
    ].map((x) => {
      return { ...x, nodoc: false };
    });
    api['contextMenus'].types?.push(...clone);
  }

  // Fix contextMenus.onClicked incorrectly $ref-ing another function.
  const onClickedEvent = api['contextMenus'].events?.find(({name}) => name === 'onClicked');
  if (onClickedEvent && onClickedEvent.$ref) {
    delete onClickedEvent.$ref;
    onClickedEvent.parameters = [
      { $ref: 'OnClickData', name: 'info' },
      { $ref: 'tabs.Tab', name: 'tab' },
    ];
  }
}


/**
 * @implements {overrideTypes.RenderOverride}
 */
class RenderOverride {
  #commentRewriter;
  #fq;

  /**
   * @param {Iterable<string>} allNamespaceNames
   * @param {FeatureQuery} fq
   */
  constructor(allNamespaceNames, fq) {
    this.#commentRewriter = buildNamespaceAwareMarkdownRewrite(allNamespaceNames);
    this.#fq = fq;
  }

  /**
   * @param {chromeTypes.TypeSpec} spec
   * @param {string} id
   */
  isVisible(spec, id) {
    // Hide a number of internal APIs.
    const parts = id.split('.');
    if (['api:test', 'api:idltest'].includes(parts[0])) {
      return false;
    }
    const invalid = parts.some((part) => {
      return part.endsWith('Private') || part.endsWith('Internal');
    })
    if (invalid) {
      return false;
    }

    if (!this.#fq.isAvailable(id)) {
      console.warn('skipping', id);
      return false;
    }

    switch (id) {
      case 'api:notifications.NotificationBitmap':
        // In old versions of Chrome, this is incorrectly marked nodoc.
        return true;

      case 'api:declarativeContent.ShowAction':
        // This is incorrectly referenced even though it's marked nodoc.
        return true;
    }
    return !spec.nodoc;
  }

  /**
   * @param {string} id
   */
  objectTemplatesFor(id) {
    switch (id) {
      case 'api:events.Event':
        return 'H, C = void, A = void';

      case 'api:events.Rule':
        return 'C = any, A = any';

      case 'api:contentSettings.ContentSetting':
        return 'T';

      case 'api:types.ChromeSetting':
        return 'T';
    }
  }

  /**
   * @param {chromeTypes.TypeSpec} spec
   * @param {string} id
   */
  typeOverride(spec, id) {
    // Replace callback types to do with Event.
    switch (id) {
      case 'api:events.Event.addListener.callback':
      case 'api:events.Event.removeListener.callback':
      case 'api:events.Event.hasListener.callback':
        return { $ref: 'H' };

      case 'api:events.Event.addRules.rules._':
      case 'api:events.Event.addRules.callback.rules._':
      case 'api:events.Event.getRules.callback.rules._':
        return { $ref: 'Rule', value: ['', { $ref: 'C' }, { $ref: 'A' }] };
    }

    // Fix bad runtime.Port APIs in older Chrome versions.
    if (spec.$ref === 'events.Event' && !spec.value) {
      /** @type {chromeTypes.TypeSpec[]} */
      const parameters = [];

      /** @type {chromeTypes.TypeSpec} */
      const functionType = { type: 'function', parameters };

      /** @type {chromeTypes.TypeSpec} */
      const update = { ...spec, value: ['', functionType] };

      switch (id) {
        case 'api:runtime.Port.onMessage':
          parameters.push({ type: 'any', name: 'message' });
          // fall-through

        case 'api:runtime.Port.onDisconnect':
          parameters.push({ $ref: 'Port', name: 'port' });
          break;
      }

      return update;
    }

    // Fix bad contextMenusInternal references in older Chrome versions.
    if (spec.$ref && spec.$ref.startsWith('contextMenusInternal.') && !id.startsWith('api:contextMenusInternal.')) {
      spec.$ref = spec.$ref.replace(/^contextMenusInternal\./, 'contextMenus.');
    }

    // Fix isInstanceOf usages.
    switch (spec.isInstanceOf) {
      case 'Promise':
        return { $ref: 'Promise', value: ['', { type: 'any' }] };

      case 'global':
        return { $ref: 'Window' };
    }

    // Upgrade ambiguous "any" to better template types as needed.
    if (spec.type === 'any') {
      switch (id) {
        case 'api:events.Rule.conditions._':
          return { $ref: 'C' };

        case 'api:events.Rule.actions._':
          return { $ref: 'A' };

        case 'api:contentSettings.ContentSetting.get.return.setting':
        case 'api:contentSettings.ContentSetting.get.callback.details.setting':
        case 'api:types.ChromeSetting.set.details.setting':
          return { $ref: 'T' };

        case 'api:types.ChromeSetting.onChange.details.value':
        case 'api:types.ChromeSetting.get.return.value':
        case 'api:types.ChromeSetting.get.callback.details.value':
        case 'api:types.ChromeSetting.set.details.value':
          return { $ref: 'T' };
      }
    }
  }

  /**
   * @param {chromeTypes.TypeSpec} spec
   * @param {string} id
   */
  tagsFor(spec, id) {
    // TODO: missing for now
    if (1) {
      return [];
    }
  }

  /**
   * @param {string} s
   * @param {string} id
   */
  rewriteComment(s, id) {
    const namespace = namespaceNameFromId(id);
    const update = this.#commentRewriter(namespace, s);
    if (update !== s) {
      return update;
    }
  }
}


run();
